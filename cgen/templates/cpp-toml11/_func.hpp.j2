typedef toml::value config_data_t;

inline config_data_t load_file(
    const std::string& filepath)
{
    return toml::parse(filepath, toml::spec::v(1,1,0));
}
{% if opt.use_validate %}
inline void validate(
    const config_data_t& data)
{
}
{% endif %}
inline bool contains_key(
    const config_data_t& data,
    const char* key,
    [[maybe_unused]] config_options opts)
{
    return data.contains(key);
}

inline const config_data_t& get_key(
    const config_data_t& data,
    const char* key,
    [[maybe_unused]] config_options opts)
{
    return data.at(key);
}

template<typename T>
inline void from_data(
    const config_data_t& data,
    T& value,
    [[maybe_unused]] config_options opts)
{
    assert(false);
}

inline void from_data(
    const config_data_t& data,
    bool& value,
    [[maybe_unused]] config_options opts)
{
    value = data.as_boolean();
}

inline void from_data(
    const config_data_t& data,
    int& value,
    [[maybe_unused]] config_options opts)
{
    value = data.as_integer();
}

inline void from_data(
    const config_data_t& data,
    unsigned int& value,
    [[maybe_unused]] config_options opts)
{
    value = data.as_integer();
}

inline void from_data(
    const config_data_t& data,
    double& value,
    [[maybe_unused]] config_options opts)
{
    value = data.as_floating();
}

inline void from_data(
    const config_data_t& data,
    float& value,
    [[maybe_unused]] config_options opts)
{
    value = data.as_floating();
}

inline void from_data(
    const config_data_t& data,
    std::string& value,
    [[maybe_unused]] config_options opts)
{
    value = data.as_string();
}

template<typename T>
inline void from_data(
    const config_data_t& data,
    std::vector<T>& value,
    config_options opts)
{
    for (const auto& child : data.as_array())
    {
        T tmp;
        from_data(child, tmp, opts);
        value.push_back(tmp);
    }
}

template<typename K, typename V>
inline void from_data(
    const config_data_t& data,
    std::map<K,V>& value,
    config_options opts)
{
    for (const auto& child : data.as_table())
    {
        auto key = config::from_string<K>(child.first);
        V val;
        from_data(child.second, val, opts);
        value.insert(std::make_pair(key, val));
    }
}
