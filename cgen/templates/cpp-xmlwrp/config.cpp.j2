{%- import '_macros.j2' as m -%}

{#-
  Renders forward declarations for load functions
  @param types         List of types [objects]
  @param unique_types  List of unique type names [strings]
-#}
{%- macro forward_declarations(types, unique_types) -%}
{%- for type in types -%}
{%- if type.type == 'object' and type.name in unique_types -%}
struct {{ m.type_case(type.name) }} Load{{ m.type_case(type.name) }}(const xml::Node& node);
{% endif -%}
{%- endfor -%}
{%- endmacro -%}

{#-
  Renders a list of load functions
  @param types         List of types [objects]
  @param unique_types  List of unique type names [strings]
-#}
{%- macro load_functions(types, unique_types) -%}
{%- if types -%}
{%- for type in types -%}
{%- if type.type == 'object' and type.name in unique_types %}
{{ load_function(type) }}
{% endif -%}
{%- endfor -%}
{%- endif -%}
{%- endmacro -%}

{%- macro load_function(type) -%}
static struct {{ m.type_case(type.name) }} Load{{ m.type_case(type.name) }}(
    const xml::Node& node)
{
    struct {{ m.type_case(type.name) }} config{};
{% filter indent(4) %}
{{ load_fields('config.', type.fields) }}
{%- endfilter %}
    return config;
}
{%- endmacro -%}

{%- macro load_fields(prefix, fields) -%}
{%- for field in fields -%}
{{ load_field(prefix, field) }}
{% endfor -%}
{%- endmacro -%}

{%- macro load_field(prefix, field) -%}
{% if field.required %}XML_MANDATORY({% else %}XML_OPTIONAL({% endif -%}
{{ prefix }}{{ m.value_case(field.name) }} =
{%- if field.type.type in ['object'] %} Load{{ m.type_case(field.type.name) }}(node.GetChild("{{ field.type.alias }}"))
{%- elif field.type.type in ['array', 'list'] %} load_array<{{ m.type_name(m.get_type(field.type.item_type)) }}>(node, "{{ field.type.alias }}", Load{{ m.type_case(m.get_type(field.type.item_type)) }})
{%- elif field.type.type in ['dict', 'dictionary', 'map'] %} load_dict<{{ m.type_name(m.get_type(field.type.key_type)) }}, {{ m.type_name(m.get_type(field.type.value_type)) }}>(node.GetChild("{{ field.type.alias }}"), "item", Load{{ m.type_case(m.get_type(field.type.key_type)) }}, Load{{ m.type_case(m.get_type(field.type.value_type)) }})
{%- elif field.type.type in ['enum'] %}
  {%- if field.type.base_type in ['string'] %} load_enum<{{ m.type_case(field.type.name) }}>(node, "{{ field.type.alias }}")
  {%- else %} config::from_string<{{ m.type_name(field.type.base_type) }}>(node.GetStringProp("{{ field.name }}"){% if field.type.base and field.type.base != 10 %}, {{ field.type.base }}{% endif %})
  {%- endif %}
{%- else %} config::from_string<{{ m.type_name(field.type.type) }}>(node.GetStringProp("{{ field.name }}"){% if field.type.base and field.type.base != 10 %}, {{ field.type.base }}{% endif %})
{%- endif -%}
);
{%- endmacro -%}


{#-
  Renders a list of Print functions
  @param types         List of types [objects]
  @param unique_types  List of unique type names [strings]
-#}
{%- macro print_functions(types, unique_types) -%}
{%- if types -%}
{%- for type in types -%}
{%- if type.type == 'object' and type.name in unique_types %}
{{ print_function(type) }}
{% endif -%}
{%- endfor -%}
{%- endif -%}
{%- endmacro -%}

{%- macro print_function(type) -%}
template<>
void Print<{{ m.type_case(type.name) }}>(
    std::ostream& os,
    const {{ m.type_case(type.name) }}& config,
    int indentLevel,
    const char* prefix)
{
    os << std::setw(indentLevel) << "" << prefix << "\n";
{%- filter indent(4) -%}
{{ print_fields('config.', type.fields) }}
{%- endfilter %}
}
{%- endmacro -%}

{%- macro print_fields(prefix, fields) -%}
{% for field in fields %}
{{ print_field(prefix, field) }}
{%- endfor -%}
{%- endmacro -%}

{%- macro print_field(prefix, field) -%}
{%- if field.type.type in ['object'] %}Print<{{ m.type_case(field.type.name) }}>(os, {{ prefix }}{{ m.value_case(field.name) }}, indentLevel + 2, "{{ field.name }} ");
{%- elif field.type.type in ['array', 'list'] %}print_array<{{ m.type_name(m.get_type(field.type.item_type)) }}>(os, {{ prefix }}{{ m.value_case(field.name) }}, static_cast<void(*)(std::ostream&, const {{ m.type_name(m.get_type(field.type.item_type)) }}&, int, const char*)>(Print<{{ m.type_name(m.get_type(field.type.item_type)) }}>), indentLevel, "{{ field.name }} ");
{%- elif field.type.type in ['dict', 'dictionary', 'map'] %} print_dict<{{ m.type_name(m.get_type(field.type.key_type)) }}, {{ m.type_name(m.get_type(field.type.value_type)) }}>(os, "item", Print<{{ m.type_name(m.get_type(field.type.key_type)) }}>, Print<{{ m.type_name(m.get_type(field.type.value_type)) }}>)
{%- else %}
    {%- if field.type.base and field.type.base != 10 %}Print(os, {{ prefix }}{{ m.value_case(field.name) }}, {{ field.type.base }}, indentLevel + 2, "{{ field.name }}: ");
    {%- else %}Print(os, {{ prefix }}{{ m.value_case(field.name) }}, indentLevel + 2, "{{ field.name }}: ");
    {%- endif -%}
{%- endif -%}
{%- endmacro -%}

// This file has been generated. Do not modify.

#include <functional>
#include <iostream>
#include <iomanip>

#include <libxmlwrp.hpp>

#include "{{ options['output_prefix'] | default('') }}config.hpp"
#include "embedded_resources.h"


static void GetSchemaData(
    const char*& buffer,
    size_t& size)
{
    BINARY_RESOURCE_DATA(xsd_data, {{ info.title | default('config') | replace('-', '_') }}, xsd);
    BINARY_RESOURCE_SIZE(xsd_size, {{ info.title | default('config') | replace('-', '_') }}, xsd);

    buffer = reinterpret_cast<const char*>(xsd_data);
    size = xsd_size;
}

{% if options['cpp'] and options['cpp']['namespaces'] | default([]) | length > 0 %}
{%- for namespace in options['cpp']['namespaces'] %}
namespace {{ namespace }} {
{%- endfor %}
{%- else %}
namespace config {
{%- endif %}

#include "from_string.hpp"

template<typename E>
E load_enum(
    const xml::Node& node,
    const char* attr)
{
    E e;
    if (!from_string(node.GetStringProp(attr).c_str(), e))
    {
        throw std::invalid_argument("invalid enum value");
    }
    return e;
}

template<typename T>
std::vector<T> load_array(
    const xml::Node& node,
    const char* name,
    std::function<T(const xml::Node&)> f)
{
    std::vector<T> v;
    for (const auto& child : node.GetChildren(name))
    {
        v.push_back(f(child));
    }
    return v;
}

template<typename K, typename V>
std::map<K,V> load_dict(
    const xml::Node& node,
    const char* name,
    std::function<std::pair<K,V>(const xml::Node&)> f)
{
    std::map<K,V> m;
    for (const auto& child : node.GetChildren(name))
    {
        auto [key, value] = f(child);
        m[key] = value;
    }
    return m;
}

[[maybe_unused]] static std::string LoadString(
    const xml::Node& node)
{
    return node.GetStringVal();
}

[[maybe_unused]] static int LoadInt(
    const xml::Node& node)
{
    return node.GetIntVal();
}

[[maybe_unused]] static unsigned int LoadUint(
    const xml::Node& node)
{
    return node.GetUIntVal();
}

[[maybe_unused]] static bool LoadBool(
    const xml::Node& node)
{
    return node.GetBoolVal();
}

// TODO: implement standard types



template<typename T>
void print_array(
    std::ostream& os,
    const std::vector<T>& v,
    std::function<void(std::ostream&, const T&, int, const char*)> print,
    int indentLevel,
    const char* name)
{
    for (const auto& item : v)
    {
        print(os, item, indentLevel + 2, name);
    }
}

template<typename K, typename V>
void print_dict(
    std::ostream& os,
    const std::map<K, V>& m,
    const char* name,
    std::function<void(std::ostream&, const K&, int)> pK,
    std::function<void(std::ostream&, const K&, int)> pV,
    int indentLevel)
{
    for (const auto& [key, value] : m)
    {
        os << std::setw(indentLevel) << "" << name << "\n";
        os << std::setw(indentLevel + 2) << "" << "key:" << "\n";
        pK(os, key, value, indentLevel + 4);
        os << std::setw(indentLevel + 2) << "" << "value:" << "\n";
        pV(os, key, value, indentLevel + 4);
    }
}

template<typename T>
void Print(
    std::ostream& os,
    const T& config,
    int indentLevel,
    const char* prefix)
{
    os << std::setw(indentLevel) << "" << prefix << config << "\n";
}

{% if options['cpp'] and options['cpp']['use_optional'] | default(false) -%}
template<typename T>
void Print(
    std::ostream& os,
    const std::optional<T>& config,
    int indentLevel,
    const char* prefix)
{
    if (!config)
    {
        return;
    }
    Print(os, config.value(), indentLevel, prefix);
}
{%- endif %}

template<>
void Print<bool>(
    std::ostream& os,
    const bool& config,
    int indentLevel,
    const char* prefix)
{
    os << std::setw(indentLevel) << "" << prefix << std::boolalpha << config << "\n";
}

template<typename T>
void Print(
    std::ostream& os,
    T value,
    int base,
    int indentLevel,
    const char* prefix)
{
    os << std::setw(indentLevel) << "" << prefix;

    switch (base)
    {
        case 8:
            os << "0" << std::oct << value;
            break;
        case 16:
            os << "0x" << std::hex << std::uppercase << static_cast<int>(value);
            break;
        default:
            os << value;
            break;
    }
    os << std::dec << "\n";
}

{% if options['cpp'] and options['cpp']['use_optional'] | default(false) -%}
template<typename T>
void Print(
    std::ostream& os,
    std::optional<T> value,
    int base,
    int indentLevel,
    const char* prefix)
{
    if (!value)
    {
        return;
    }
    Print(os, value.value(), base, indentLevel, prefix);
}
{%- endif %}


{% if types -%}
{{ load_functions(types, unique_types) }}
{%- endif -%}
{%- if elements -%}
{{ load_functions(elements, unique_elements) }}
{%- endif -%}

{% if types -%}
{{ print_functions(types, unique_types) }}
{%- endif -%}
{%- if elements -%}
{{ print_functions(elements, unique_elements) }}
{% endif -%}

static void ValidateConfig(
    const xml::Document& doc)
{
    const char* data;
    size_t size = 0;
    GetSchemaData(data, size);

    xml::Schema schema{data, size};

    if (!schema.IsValid(doc))
    {
        throw xml::Exception("ERROR: configuration is not valid");
    }
}

bool ValidateConfig(
    const std::string& configPath)
{
    try
    {
        xml::Document doc{configPath.c_str()};

        ValidateConfig(doc);

        return true;
    }
    catch (const std::exception& ex)
    {
        std::cerr << ex.what() << "\n\n";
    }

    return false;
}

std::unique_ptr<Config> LoadConfig(
    const std::string& configPath)
{
{%- if elements %}
    try
    {
        xml::Document doc{configPath.c_str()};

        ValidateConfig(doc);

        auto node = doc.GetRootNode();

        auto config = std::make_unique<struct Config>();

        {% filter indent(8) -%}
        {{ load_fields('config->', config.fields) }}
        {%- endfilter %}
        return config;
    }
    catch (const std::exception&)
    {
        throw;
    }
{%- endif %}
}

std::ostream& operator<<(
    std::ostream& os,
    const Config& config)
{
    constexpr int indentLevel = 0;
    {% filter indent(4) -%}
    {{ print_fields('config.', config.fields) }}
    {%- endfilter %}
    return os;
}
{% if options['cpp'] and options['cpp']['namespaces'] | default([]) | length > 0 %}
{%- for namespace in options['cpp']['namespaces'] %}
} // namespace {{ namespace }}
{%- endfor %}
{%- else %}
} // namespace config
{%- endif %}

